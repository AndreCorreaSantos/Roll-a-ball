#pragma kernel CSMain

struct BoidInfo
{
    float3 position;
    float3 forward;
};

float3 normalizeSafe(float3 v)
{
    return length(v) > 0 ? normalize(v) : float3(0, 0, 0);
}

RWStructuredBuffer<BoidInfo> inputBuffer;
uint numBoids;
float deltaTime;
float3 targetPosition;
half separationWeight;
half alignmentWeight;
half targetWeight;
half cohesionWeight;
half moveSpeed;
half noClumpingRadius;
half cohesionRadius;
half targetRadius; // New parameter for target avoidance radius

[numthreads(512,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint boidIndex = id.x;
    BoidInfo boidSelf = inputBuffer[boidIndex];
    float3 cellAlignment = float3(0, 0, 0);
    float3 cellCenter = float3(0, 0, 0);
    float3 cellSeparation = float3(0, 0, 0);
    int boidsInClumpingRadius = 0;
    int boidsCountForAlignmentAndCohesion = 0;

    for (uint i = 0; i < numBoids; ++i)
    {
        if (i == boidIndex) continue; 
    
        BoidInfo boidOther = inputBuffer[i];
        float3 distance = boidOther.position - boidSelf.position;

        if (length(distance) < noClumpingRadius)
        {
            cellSeparation += (boidSelf.position - boidOther.position);
            boidsInClumpingRadius++;
        }

        if (length(distance) > cohesionRadius) continue; // cohesion radius used for alginment and cohesion
        cellAlignment += boidOther.forward;
        cellCenter += boidOther.position;
        boidsCountForAlignmentAndCohesion++;
    }

    cellAlignment = boidsCountForAlignmentAndCohesion > 0 ? cellAlignment / boidsCountForAlignmentAndCohesion : float3(0, 0, 0);
    cellCenter = boidsCountForAlignmentAndCohesion > 0 ? cellCenter / boidsCountForAlignmentAndCohesion : float3(0, 0, 0);

    if (boidsInClumpingRadius > 0)
    {
        cellSeparation /= boidsInClumpingRadius;
    }

    const float3 alignmentDirection = alignmentWeight * normalizeSafe(cellAlignment - boidSelf.forward);
    const float3 separationDirection = separationWeight * normalizeSafe(cellSeparation);
    
    // Updated target direction logic to run away from the target within a specified radius
    float3 toTarget = targetPosition - boidSelf.position;
    float3 targetDirection = float3(0, 0, 0);
    if(length(toTarget) < targetRadius) {
        targetDirection = targetWeight * -normalizeSafe(toTarget); // Run away
    }

    const float3 cohesionDirection = cohesionWeight * normalizeSafe(cellCenter - boidSelf.position);

    const float3 normalDirection = normalizeSafe(alignmentDirection + separationDirection + cohesionDirection + targetDirection);
    const float3 nextDirection = normalizeSafe(boidSelf.forward + deltaTime * (normalDirection - boidSelf.forward));

    // Update Boid
    boidSelf.position = boidSelf.position + (nextDirection * moveSpeed * deltaTime);
    boidSelf.forward = nextDirection;
    inputBuffer[boidIndex] = boidSelf;
}
